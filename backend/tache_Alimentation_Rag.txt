ðŸ“‹ Les 7 Ã©tapes du workflow
Ã‰TAPE 1 : CrÃ©ation d'un ticket de test ðŸŽ«
Question : "Mon VPN ne se connecte plus, j'ai un message d'erreur timeout"
    â†“
Analyse automatique :
- CatÃ©gorie dÃ©tectÃ©e : "RÃ©seau" (via clustering)
- PrioritÃ© : "Moyenne"
    â†“
Ticket #X crÃ©Ã© en base PostgreSQL

Ã‰TAPE 2 : Simulation de rÃ©solution par un technicien ðŸ‘¨â€ðŸ’»
Le systÃ¨me simule qu'un technicien (Jean Dupont) rÃ©sout le ticket :

Solution proposÃ©e :
"Le problÃ¨me venait d'une mauvaise configuration du pare-feu.
ProcÃ©dure :
1. Ouvrir Windows Defender Firewall
2. Autoriser Cisco AnyConnect
3. RedÃ©marrer le service VPN
4. Tester la connexion

Le VPN fonctionne maintenant."

Ã‰TAPE 3 : Mise Ã  jour du ticket âœï¸
Ticket mis Ã  jour :
- Status : "Nouveau" â†’ "RÃ©solu"
- Technicien : "Jean Dupont (Test)"
- Solution : ajoutÃ©e
- Date de rÃ©solution : maintenant

Ã‰TAPE 4 : GÃ©nÃ©ration de l'embedding ðŸ§ 
Construction du texte RAG complet :
"CatÃ©gorie: RÃ©seau
ProblÃ¨me: ProblÃ¨me connexion VPN
Description: Mon VPN ne se connecte plus...
Solution: Le problÃ¨me venait du pare-feu..."

    â†“
Ollama gÃ©nÃ¨re un vecteur 768D (via nomic-embed-text)
    â†“
Embedding sauvegardÃ©
C'est l'Ã©tape la plus longue (~3-5 secondes avec Ollama) â³

Ã‰TAPE 5 : Alimentation de la base RAG ðŸ”¥
CrÃ©ation dans PostgreSQL :
- Table Question : nouvelle entrÃ©e avec embedding
- Table Reponse : solution du technicien (validitÃ©=1)
- Lien : ticket.question_id â†’ nouvelle entrÃ©e RAG

Ã‰TAPE 6 : Test de recherche RAG ðŸ”
Question similaire posÃ©e :
"J'ai un souci avec le VPN, Ã§a ne marche pas"

    â†“
Le RAG cherche dans la base (similaritÃ© cosine)
    â†“
Trouve des sources (dont la solution de Jean Dupont !)
    â†“
Mistral gÃ©nÃ¨re une rÃ©ponse avec le contexte
Ã‰tape aussi un peu longue (~2-3 secondes avec Mistral) â³

Ã‰TAPE 7 : RÃ©sultat final âœ…
Retourne :
{
  "success": true,
  "workflow": "Ticket crÃ©Ã© â†’ RÃ©solu â†’ AjoutÃ© au RAG â†’ TestÃ©",
  "steps": {
    "1_ticket_created": {...},
    "2_ticket_resolved": {...},
    "3_rag_tested": {
      "sources_found": X  â† Important !
    }
  },
  "conclusion": "âœ… Workflow complet fonctionnel !"
}


Question : "Mon logiciel Adobe Photoshop 2025 plante..."
    â†“
Clustering analyse les mots-clÃ©s : "logiciel", "Adobe", "Photoshop"
    â†“
CatÃ©gorie dÃ©tectÃ©e : "Logiciel"
    â†“
get_technician_email("Logiciel") â†’ "tech.logiciel@univ-corse.fr"

â±ï¸ Temps estimÃ©

Sans GLPI rÃ©el : ~8-12 secondes
Avec GLPI rÃ©el : ~10-15 secondes (crÃ©ation ticket dans GLPI)

Les Ã©tapes les plus longues :

ðŸ“Š GÃ©nÃ©ration embedding (3-5 sec)
ðŸ¤– GÃ©nÃ©ration rÃ©ponse Mistral (2-3 sec)


ðŸŽ¯ Ce que Ã§a prouve
Si le test rÃ©ussit :

âœ… Clustering fonctionne (catÃ©gorisation auto)
âœ… Base PostgreSQL fonctionne
âœ… Ollama fonctionne (embeddings + gÃ©nÃ©ration)
âœ… Webhook fonctionne
âœ… RAG s'enrichit automatiquement
âœ… Recherche sÃ©mantique fonctionne
âœ… SystÃ¨me complet opÃ©rationnel !


Alimentation du RAG !
un endpoint : /glpi/webhook/ticket-resolved qui va appeler GLPIWebhookRequest lorsque le tech rÃ©sout le ticket:
Ce qu'il fait :

âœ… ReÃ§oit la solution du technicien
âœ… Met Ã  jour le ticket (status â†’ "RÃ©solu")
âœ… Construit un texte RAG complet
âœ… GÃ©nÃ¨re l'embedding (768D via Ollama)
âœ… CrÃ©e l'entrÃ©e dans la table Question
âœ… CrÃ©e l'entrÃ©e dans la table Reponse
âœ… Lie le ticket Ã  l'entrÃ©e RAG

Pour que GLPI appelle ton webhook automatiquement, il faut configurer le webhook dans GLPI

GLPITicket (id: 6)
    â†“ question_id
Question (id: 10 ou 11)
    â†“ embedding_question = [768 nombres]
    â†“
Reponse (id: 11)
    â†“ reponse_label = "Solution du technicien..."

Toutes les 1 minute :
    â†“
GLPI vÃ©rifie la file d'attente des webhooks
    â†“
S'il y a des webhooks en attente
    â†“
Les envoie automatiquement Ã  ton API
    â†“
Ton API alimente le RAG


ask:
curl -X POST http://localhost:8000/ask/ ^
  -H "Content-Type: application/json" ^
  -d "{\"user_ad_id\": 1, \"question\": \"Mon tÃ©lÃ©phone IP Cisco ne fonctionne plus depuis ce matin. Pas de tonalitÃ©, l'Ã©cran affiche erreur rÃ©seau.\"}"

glpi:
curl -X POST http://localhost:8000/glpi/create-ticket ^
  -H "Content-Type: application/json" ^
  -d "{\"user_ad_id\": 1, \"title\": \"TÃ©lÃ©phone IP Cisco en panne\", \"description\": \"Mon tÃ©lÃ©phone IP Cisco ne fonctionne plus depuis ce matin. Pas de tonalitÃ©, l'Ã©cran affiche erreur rÃ©seau.\"}"

question similaire 
curl -X POST http://localhost:8000/ask/ ^
  -H "Content-Type: application/json" ^
  -d "{\"user_ad_id\": 2, \"question\": \"Mon tÃ©lÃ©phone VoIP ne fonctionne plus, pas de tonalitÃ©\"}"


curl -X POST http://localhost:8000/glpi/create-ticket ^
  -H "Content-Type: application/json" ^
  -d "{\"user_ad_id\": 1, \"title\": \"Scanner en panne\", \"description\": \"Mon scanner Canon ne fonctionne plus. Il n'est pas dÃ©tectÃ© par Windows. Le cÃ¢ble USB est bien branchÃ©.\"}"

# verifier le ticket rÃ©solu 
curl http://localhost:8000/glpi/ticket/6(id-ticket en cours)
# voir les stats:
curl http://localhost:8000/glpi/stats

curl -X POST http://localhost:8000/glpi/create-ticket ^
  -H "Content-Type: application/json" ^
  -d "{\"user_ad_id\": 1, \"title\": \"Test webhook automatique\", \"description\": \"Clavier ne fonctionne plus - touches A et Z dÃ©fectueuses\"}"



docker exec -it postgres_db psql -U user -d mydatabase -c "SELECT id, question_label FROM question WHERE question_label ILIKE '%webcam%' OR question_label ILIKE '%camera%' ORDER BY id DESC;"

REponse nn vides seules:
docker exec -it postgres_db psql -U user -d mydatabase -c "SELECT r.id, r.question_id, LEFT(q.question_label, 60) as question, LEFT(r.reponse_label, 100) as reponse FROM reponse r JOIN question q ON r.question_id = q.id WHERE (q.question_label ILIKE '%webcam%' OR q.question_label ILIKE '%camera%') AND r.reponse_label IS NOT NULL AND LENGTH(r.reponse_label) > 50 ORDER BY r.id DESC;"

